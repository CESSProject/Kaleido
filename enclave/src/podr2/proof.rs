// This is for testing purpose. The main implementation will be on storage miner side.

use core::ops::Add;

use alloc::{string::ToString, vec::Vec};
use cess_curve::Zr;
use sgx_rand::{
    distributions::{IndependentSample, Range},
    thread_rng, Rng,
};

use crate::{param::podr2_commit_data::PoDR2Chal, pbc, secret_exchange::hex::hex_to_bigint};

// Actual Challenge will be generated by the CESS nodes.
pub fn gen_chal(phi_len: usize) -> PoDR2Chal {
    let mut chal = PoDR2Chal::new();

    let mut rng = thread_rng();

    // Randomly select number of blocks
    let between = Range::new(1, phi_len.add(1));
    let n = between.ind_sample(&mut rng);

    // Choose random blocks
    chal.i = sgx_rand::sample(&mut rng, 0..phi_len, n);
    chal.i.sort();

    for i in 0..n {
        let zr = Zr::random();
        let zr = pbc::get_zr_from_hash(&zr.base_vector().to_vec());
        chal.vi.push(zr.base_vector().to_vec());
    }
    chal
}

// Generates proof P = {μ, σ, {H(mi), Ωi} where s1 <= i <= sc, sig(H(R))}
// 1. Compute μ = ν0.m0 + ν1.m1 ... νi.mi, where s1 <= i <= sc, belongs to Zp
// 2. Compute σ = σ0^ν0 . σ1^ν1 ... σi^νi where s1 <= i <= sc, belongs to G
// 3. Generate Partial Merkle Hashes Tree (PMHT)
// 4. Sign PMHT root H(R)^sk
pub fn gen_proof(chal: PoDR2Chal, data: &mut Vec<u8>, phi_len: usize) {
    if chal.i.len() != chal.vi.len() {
        warn!("Invalid Challenge");
        return;
    }

    let block_size = (data.len() as f32 / phi_len as f32) as usize;

    // let mu;
    // Compute μ & σ
    for n in 0..chal.i.len() {
        let i = chal.i[n];

        let mi: Vec<u8> = if i == phi_len - 1 {
            data[i * block_size..].to_vec()
        } else {
            data[i * block_size..(i + 1) * block_size].to_vec()
        };

        let bmi = hex_to_bigint(&mi);
        let bmi = match bmi {
            Some(d) => d,
            None => {
                debug!("Converting mi to BigInteger Failed");
                return;
                // return Err(PoDR2Error {
                //     message: Some("Converting mi to BigInteger Failed".to_string()),
                // })
            }
        };

        let vi_mi = pbc::zr_mul_mpz(&Zr::random(), bmi.to_string());
        println!("vi_mi {}", vi_mi);
    }
}

// Verification of the generated proof from gen_proof will be performed by CESS nodes.
pub fn verify() {
    println!("Implement verify");
}
