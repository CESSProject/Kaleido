// This is for testing purpose. The main implementation will be on storage miner side.

use core::{array::TryFromSliceError, convert::TryInto, fmt::Error, ops::Add};

use alloc::{string::ToString, vec::Vec};
use cess_curve::{hash, PublicKey, Zr, G1};
use merkletree::{hash::Algorithm, merkle::MerkleTree, proof::Proof};
use sgx_rand::{
    distributions::{IndependentSample, Range},
    thread_rng, Rng,
};

use crate::{
    merkletree_generator::Sha256Algorithm,
    param::podr2_commit_data::{MHTProof, PoDR2Chal, PoDR2Data, PoDR2Error, PoDR2Proof},
    pbc,
    podr2::get_mht,
    attestation::hex::bytes_to_bigint,
};

// Actual Challenge will be generated by the CESS nodes.
/// {(i, vi)}s1<=i<=sc
pub fn gen_chal(phi_len: usize) -> PoDR2Chal {
    let mut chal = PoDR2Chal::new();

    let mut rng = thread_rng();

    // Randomly select total number of blocks, 1 <= n <= phi_len blocks
    let between = Range::new(1, phi_len.add(1));
    let n = between.ind_sample(&mut rng);

    // Choose random blocks
    chal.i = sgx_rand::sample(&mut rng, 0..phi_len, n);
    chal.i.sort();

    // vi For each i belongs to I
    for i in 0..n {
        let zr = Zr::random();
        let zr = pbc::get_zr_from_bytes(&zr.base_vector().to_vec());
        chal.vi.push(zr.base_vector().to_vec());
    }
    chal
}

// Generates proof P = {μ, σ, {H(mi), Ωi}s1 <= i <= sc, sig(H(R))}
// 1. Compute μ = ν0.m0 + ν1.m1 ... νi.mi, where s1 <= i <= sc, belongs to Zp
// 2. Compute σ = σ0^ν0 . σ1^ν1 ... σi^νi where s1 <= i <= sc, belongs to G
// 3. Generate {Ωi}s1<=i<=sc, i.e. node siblings on the path from the leaves {h(H(mi))}s1<=i<=sc to the root R of MHT.
// 4. sig_sk(H(R)) received during PoDR2 sig_gen()
pub fn gen_proof(
    chal: &PoDR2Chal,
    podr2: &PoDR2Data,
    data: &mut Vec<u8>,
) -> Result<PoDR2Proof, PoDR2Error> {
    if chal.i.len() != chal.vi.len() {
        warn!("Invalid Challenge");
        return Err(PoDR2Error {
            message: Some("Invalid Challenge".to_string()),
        });
    }

    let phi_len = podr2.phi.len();
    let block_size = (data.len() as f32 / phi_len as f32) as usize;

    let mu: Zr = Zr::zero();
    let mut sigma: G1 = G1::zero();
    let mut podr2_proof = PoDR2Proof::new();

    let mht = get_mht(data, podr2.phi.len())?;

    // Compute μ and σ
    for n in 0..chal.i.len() {
        let i = chal.i[n];

        let mi: Vec<u8> = if i == phi_len - 1 {
            data[i * block_size..].to_vec()
        } else {
            data[i * block_size..(i + 1) * block_size].to_vec()
        };

        let vi = pbc::get_zr_from_bytes(&chal.vi[n]);

        // vi.mi
        let vi_mi = vi;
        pbc::zr_mul_zr(&vi_mi, &pbc::get_zr_from_bytes(&mi));

        // μ = ν0.m0 + ν1.m1 ... νi.mi
        pbc::add_zr(&mu, &vi_mi);

        let sig_i = pbc::get_g1_from_bytes(&podr2.phi[i]);

        // σi^νi
        let sig_i_pow_vi = sig_i;
        pbc::g1_pow_zn(&sig_i_pow_vi, &vi);

        // σ = σ0^ν0 . σ1^ν1 ... σi^νi
        pbc::g1_mul_g1(&sigma, &sig_i_pow_vi);

        // H(mi)
        podr2_proof
            .mi_hashs
            .push(hash(mi.as_slice()).base_vector().to_vec());

        // Generate Partial Merkle Tree {Ωi}s1 <= i <= sc
        let mht_proof = mht.gen_proof(i);
        let mut proof = MHTProof::new();

        for l in mht_proof.lemma() {
            proof.lemma.push(l.to_vec());
        }
        proof.path = mht_proof.path().to_vec();

        podr2_proof.omega.push(proof);
    }

    podr2_proof.mu = mu.base_vector().to_vec();
    podr2_proof.sigma = sigma.base_vector().to_vec();
    podr2_proof.mht_root_sig = podr2.mht_root_sig.clone();

    Ok(podr2_proof)
}

// Verification of the generated proof from gen_proof will be performed by CESS nodes.
pub fn verify(proof: &PoDR2Proof, podr2_data: &PoDR2Data, chal: &PoDR2Chal) -> bool {
    // 1. Verify MHT root R e(sig_sk(H(R)),g) ?= e (H(R), g^sk)
    // 2. Verify e(σ, g) ?= e(H(m0)^v0.u^μ + H(m1)^v1.u^μ + ... + H(mi)^vi.u^μ, v)
    // v = public key
    // vi can be obtained from the challenge created.
    // u can be obtained from sig_gen
    // μ & σ from PoDR2Proof.

    // Verify MHT root R e(sig_sk(H(R)),g) ?= e (H(R), g^sk)
    for proof in &proof.omega {
        if !is_valid_pmt(proof) {
            warn!("Invalid PMT");
            return false;
        }
    }
    println!("PMT Verified Successfully");

    let root = proof.get_root();
    let root = match root {
        None => {
            warn!("Not MHT root found!");
            return false;
        },
        Some(r) => r,
    };

    if !is_valid_mht_root(root.to_vec(), &proof.mht_root_sig, &podr2_data.pkey) {
        warn!("Invalid MHT Root");
        return false;
    }
    println!("MHT Root Verified Successfully");

    // Verify e(σ, g) ?= e(H(m0)^v0.u^μ + H(m1)^v1.u^μ + ... + H(mi)^vi.u^μ, v)
    proof.validate(chal, &podr2_data.u, &podr2_data.pkey)
}

pub fn is_valid_mht_root(root_hash: Vec<u8>, sig: &Vec<u8>, pkey: &Vec<u8>) -> bool {
    let sig = pbc::get_g1_from_bytes(sig);
    let pub_key = pbc::get_G2_from_bytes(pkey);
    cess_curve::check_message(root_hash.as_slice(), &PublicKey::new(pub_key), &sig)
}

pub fn is_valid_pmt(proof: &MHTProof) -> bool {
    // Convert Vec<u8> to [u8; 32]
    let mut lemmas: Vec<[u8; 32]> = Vec::new();

    for l in &proof.lemma {
        let lemma: Result<[u8; 32], TryFromSliceError> = l.as_slice().try_into();
        let lemma = match lemma {
            Ok(v) => v,
            Err(err) => return false,
        };
        lemmas.push(lemma);
    }

    if lemmas.len() < 2 {
        return false;
    }

    let p: Proof<[u8; 32]> = Proof::new(lemmas, proof.path.clone());
    p.validate::<Sha256Algorithm>()
}
