// This is for testing purpose. The main implementation will be on storage miner side.

use core::ops::Add;

use alloc::{string::ToString, vec::Vec};
use cess_curve::{hash, Zr, G1};
use sgx_rand::{
    distributions::{IndependentSample, Range},
    thread_rng, Rng,
};

use crate::{
    param::podr2_commit_data::{PoDR2Chal, PoDR2Data, PoDR2Error, PoDR2Proof},
    pbc,
    podr2::get_mht,
    secret_exchange::hex::bytes_to_bigint,
};

// Actual Challenge will be generated by the CESS nodes.
/// {(i, vi)}s1<=i<=sc
pub fn gen_chal(phi_len: usize) -> PoDR2Chal {
    let mut chal = PoDR2Chal::new();

    let mut rng = thread_rng();

    // Randomly select total number of blocks, 1 <= n <= phi_len blocks
    let between = Range::new(1, phi_len.add(1));
    let n = between.ind_sample(&mut rng);

    // Choose random blocks
    chal.i = sgx_rand::sample(&mut rng, 0..phi_len, n);
    chal.i.sort();

    // vi For each i belongs to I
    for i in 0..n {
        let zr = Zr::random();
        let zr = pbc::get_zr_from_hash(&zr.base_vector().to_vec());
        chal.vi.push(zr.base_vector().to_vec());
    }
    chal
}

// Generates proof P = {μ, σ, {H(mi), Ωi}s1 <= i <= sc, sig(H(R))}
// 1. Compute μ = ν0.m0 + ν1.m1 ... νi.mi, where s1 <= i <= sc, belongs to Zp
// 2. Compute σ = σ0^ν0 . σ1^ν1 ... σi^νi where s1 <= i <= sc, belongs to G
// 3. Generate {Ωi}s1<=i<=sc, i.e. node siblings on the path from the leaves {h(H(mi))}s1<=i<=sc to the root R of MHT.
// 4. sig_sk(H(R)) received during PoDR2 sig_gen()
pub fn gen_proof(
    chal: &PoDR2Chal,
    podr2: &PoDR2Data,
    data: &mut Vec<u8>,
) -> Result<PoDR2Proof, PoDR2Error> {
    if chal.i.len() != chal.vi.len() {
        warn!("Invalid Challenge");
        return Err(PoDR2Error {
            message: Some("Invalid Challenge".to_string()),
        });
    }

    let phi_len = podr2.phi.len();
    let block_size = (data.len() as f32 / phi_len as f32) as usize;

    let mu: Zr = Zr::zero();
    let mut sigma: G1 = G1::zero();
    let mut podr2_proof = PoDR2Proof::new();

    // TODO: Add Partial Merkle Tree
    // let mht = get_mht(data, podr2.phi.len())?;

    // Compute μ and σ
    for n in 0..chal.i.len() {
        let i = chal.i[n];

        let mi: Vec<u8> = if i == phi_len - 1 {
            data[i * block_size..].to_vec()
        } else {
            data[i * block_size..(i + 1) * block_size].to_vec()
        };

        let bmi = bytes_to_bigint(&mi);
        let bmi = match bmi {
            Some(d) => d,
            None => {
                warn!("Converting mi to BigInteger Failed");
                return Err(PoDR2Error {
                    message: Some("Converting mi to BigInteger Failed".to_string()),
                });
            }
        };

        let vi = pbc::get_zr_from_byte(&chal.vi[n]);

        // vi.mi
        let vi_mi = pbc::zr_mul_mpz(&vi, bmi.to_string());

        // μ = ν0.m0 + ν1.m1 ... νi.mi
        pbc::add_zr(&mu, &vi_mi);

        let sig_i = pbc::get_g1_from_byte(&podr2.phi[i]);

        // σi^νi
        pbc::g1_pow_zn(&sig_i, &vi);
        
        // σ = σ0^ν0 . σ1^ν1 ... σi^νi
        if n == 0 {
            sigma = sig_i;
        } else {
            pbc::g1_mul_g1(&sigma, &sig_i);
        }

        // H(mi)
        podr2_proof
            .mi_hashs
            .push(hash(mi.as_slice()).base_vector().to_vec());

        // TODO: Generate Multi-Node Partial Merkle Tree {Ωi}s1 <= i <= sc
        // let mht_proof = mht.gen_proof(i);

        // println!("*****PMT-{}*****", i);
        // for l in mht_proof.lemma() {
        //     println!("{:?}", base64::encode(l));
        // }
    }

    podr2_proof.mu = mu.base_vector().to_vec();
    podr2_proof.sigma = sigma.base_vector().to_vec();
    podr2_proof.mht_root_sig = podr2.mht_root_sig.clone();

    Ok(podr2_proof)
}

// Verification of the generated proof from gen_proof will be performed by CESS nodes.
pub fn verify(proof: &PoDR2Proof, podr2_data: &PoDR2Data, chal: &PoDR2Chal) -> bool {
    // 1. Verify MHT root R e(sig_sk(H(R)),g) ?= e (H(R), g^sk)
    // 2. Verify e(σ, g) ?= e(H(m0)^v0.u^μ + H(m1)^v1.u^μ + ... + H(mi)^vi.u^μ, v)
    // v = public key
    // vi can be obtained from the challenge created.
    // u can be obtained from sig_gen
    // μ & σ from PoDR2Proof.

    // TODO: 1st Verify MHT root R e(sig_sk(H(R)),g) ?= e (H(R), g^sk)

    // Verify e(σ, g) ?= e(H(m0)^v0.u^μ + H(m1)^v1.u^μ + ... + H(mi)^vi.u^μ, v)
    proof.validate(chal, &podr2_data.u, &podr2_data.pkey)
}
